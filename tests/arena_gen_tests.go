// Code generated by tangentgen; DO NOT EDIT.

package tests

import (
	pluginout "github.com/telophasehq/tangent-sdk-go"
)

// AppendToArena appends MyStruct into the arena as an object and returns the root node index.
func (x MyStruct) AppendToArena(ab *pluginout.ArenaBuilder, st *pluginout.StringTable) uint32 {
	ab.UseStringTable(st)
	ab.ObjectStartReserve(5)

	MyInt_int_idx := ab.Int(int64(x.MyInt))
	ab.ObjectAddFieldKey("my_int", MyInt_int_idx)
	MyFloat_float_idx := ab.Float(float64(x.MyFloat))
	ab.ObjectAddFieldKey("my_float", MyFloat_float_idx)
	MyString_str_idx := ab.String(x.MyString)
	ab.ObjectAddFieldKey("my_string", MyString_str_idx)
	{
		MyNested_struct_idx := x.MyNested.AppendToArena(ab, st)
		ab.ObjectAddFieldKey("my_nested", MyNested_struct_idx)
	}
	ab.ArrayStartReserve(len(x.MyList))
	for i := range x.MyList {
		ab.ArrayAdd(ab.String(x.MyList[i]))
	}
	MyList_slice_idx := ab.ArrayEnd()
	ab.ObjectAddFieldKey("my_list", MyList_slice_idx)

	return ab.ObjectEnd()
}

// AppendToArena appends MyNested into the arena as an object and returns the root node index.
func (x MyNested) AppendToArena(ab *pluginout.ArenaBuilder, st *pluginout.StringTable) uint32 {
	ab.UseStringTable(st)
	ab.ObjectStartReserve(1)

	MyNestedInt_int_idx := ab.Int(int64(x.MyNestedInt))
	ab.ObjectAddFieldKey("nested_int", MyNestedInt_int_idx)

	return ab.ObjectEnd()
}

// AppendToArena appends MyStructPtr into the arena as an object and returns the root node index.
func (x MyStructPtr) AppendToArena(ab *pluginout.ArenaBuilder, st *pluginout.StringTable) uint32 {
	ab.UseStringTable(st)
	ab.ObjectStartReserve(5)

	MyInt_int_idx := ab.Int(int64(x.MyInt))
	ab.ObjectAddFieldKey("my_int", MyInt_int_idx)
	MyFloat_float_idx := ab.Float(float64(x.MyFloat))
	ab.ObjectAddFieldKey("my_float", MyFloat_float_idx)
	MyString_str_idx := ab.String(x.MyString)
	ab.ObjectAddFieldKey("my_string", MyString_str_idx)
	if x.MyNested != nil {
		MyNested_struct_idx := x.MyNested.AppendToArena(ab, st)
		ab.ObjectAddFieldKey("my_nested", MyNested_struct_idx)
	}
	ab.ArrayStartReserve(len(x.MyList))
	for i := range x.MyList {
		ab.ArrayAdd(ab.String(x.MyList[i]))
	}
	MyList_slice_idx := ab.ArrayEnd()
	ab.ObjectAddFieldKey("my_list", MyList_slice_idx)

	return ab.ObjectEnd()
}

// AppendToArena appends MyStructAnon into the arena as an object and returns the root node index.
func (x MyStructAnon) AppendToArena(ab *pluginout.ArenaBuilder, st *pluginout.StringTable) uint32 {
	ab.UseStringTable(st)
	ab.ObjectStartReserve(5)

	MyInt_int_idx := ab.Int(int64(x.MyInt))
	ab.ObjectAddFieldKey("my_int", MyInt_int_idx)
	MyFloat_float_idx := ab.Float(float64(x.MyFloat))
	ab.ObjectAddFieldKey("my_float", MyFloat_float_idx)
	MyString_str_idx := ab.String(x.MyString)
	ab.ObjectAddFieldKey("my_string", MyString_str_idx)
	{
		ab.ObjectStartReserve(1)
		MyNestedInt_int_idx := ab.Int(int64(x.MyNested.MyNestedInt))
		ab.ObjectAddFieldKey("nested_int", MyNestedInt_int_idx)
		MyNested_struct_idx := ab.ObjectEnd()
		ab.ObjectAddFieldKey("my_nested", MyNested_struct_idx)
	}
	ab.ArrayStartReserve(len(x.MyList))
	for i := range x.MyList {
		ab.ArrayAdd(ab.String(x.MyList[i]))
	}
	MyList_slice_idx := ab.ArrayEnd()
	ab.ObjectAddFieldKey("my_list", MyList_slice_idx)

	return ab.ObjectEnd()
}

// AppendToArena appends MyStructAnonPtr into the arena as an object and returns the root node index.
func (x MyStructAnonPtr) AppendToArena(ab *pluginout.ArenaBuilder, st *pluginout.StringTable) uint32 {
	ab.UseStringTable(st)
	ab.ObjectStartReserve(5)

	MyInt_int_idx := ab.Int(int64(x.MyInt))
	ab.ObjectAddFieldKey("my_int", MyInt_int_idx)
	MyFloat_float_idx := ab.Float(float64(x.MyFloat))
	ab.ObjectAddFieldKey("my_float", MyFloat_float_idx)
	MyString_str_idx := ab.String(x.MyString)
	ab.ObjectAddFieldKey("my_string", MyString_str_idx)
	if x.MyNested != nil {
		ab.ObjectStartReserve(1)
		MyNestedInt_int_idx := ab.Int(int64((*x.MyNested).MyNestedInt))
		ab.ObjectAddFieldKey("nested_int", MyNestedInt_int_idx)
		MyNested_struct_idx := ab.ObjectEnd()
		ab.ObjectAddFieldKey("my_nested", MyNested_struct_idx)
	}
	ab.ArrayStartReserve(len(x.MyList))
	for i := range x.MyList {
		ab.ArrayAdd(ab.String(x.MyList[i]))
	}
	MyList_slice_idx := ab.ArrayEnd()
	ab.ObjectAddFieldKey("my_list", MyList_slice_idx)

	return ab.ObjectEnd()
}
