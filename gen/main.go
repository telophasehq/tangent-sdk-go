package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"go/types"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const header = `// Code generated by tangentgen; DO NOT EDIT.

`

var pkgLineRx = regexp.MustCompile(`(?m)^package\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*$`)

type fieldSpec struct {
	name      string // field name in output
	goName    string // struct field ident
	omitempty bool
	kind      fieldKind
	elem      types.Type  // for slices/maps element
	isBytes   bool        // []byte special
	fields    []fieldSpec // for nested structs
	isPtr     bool        // original field was a pointer at top-level

	named *types.Named
}

type fieldKind int

const (
	fkUnsupported fieldKind = iota
	fkString
	fkBool
	fkInt
	fkFloat
	fkBytes
	fkSlice
	fkMapString
	fkStruct
)

type genType struct {
	strct  *types.Struct
	fields []fieldSpec
}

func main() {
	log.SetFlags(0)

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax |
			packages.NeedCompiledGoFiles | packages.NeedTypes | packages.NeedTypesInfo,
		Dir: ".",
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatalf("load: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	if len(pkgs) == 0 {
		log.Fatalf("no packages found")
	}
	pkg := pkgs[0]

	// Discover the output type by locating a call to tangent_sdk.Wire[T](...)
	toGenerate := findWireOutputTypes(pkg)
	if len(toGenerate) == 0 {
		log.Fatalf("no Wire[T] instantiations found; pass -types or add a tangentgen shim")
	}

	err = runEasyJSONTypesOnly(pkg, toGenerate)
	if err != nil {
		log.Fatalf("easyjson generate failed: %v", err)
	}
}

// findWireOutputType searches the package's syntax for a call to
// github.com/telophasehq/tangent-sdk-go.Wire[T](...) and returns the
// name of T and its underlying struct type. Only named struct types are supported.
func findWireOutputTypes(pkg *packages.Package) map[*types.Named]*types.Struct {
	const tangentImportPath = "github.com/telophasehq/tangent-sdk-go"
	out := map[*types.Named]*types.Struct{}
	for _, f := range pkg.Syntax {
		ast.Inspect(f, func(n ast.Node) bool {
			call, ok := n.(*ast.CallExpr)
			if !ok {
				return true
			}
			switch fun := call.Fun.(type) {
			case *ast.IndexExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if name, st := extractNamedStructType(pkg, fun.Index); st != nil {
					out[name] = st
				}
			case *ast.IndexListExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if len(fun.Indices) > 0 {
					if name, st := extractNamedStructType(pkg, fun.Indices[0]); st != nil {
						out[name] = st
					}
				}
			}
			return true
		})
	}
	return out
}

// isTangentWire reports whether expr is a selector to the Wire symbol in the tangent SDK import.
func isTangentWire(pkg *packages.Package, expr ast.Expr, wantPath string) bool {
	sel, ok := expr.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	if sel.Sel == nil || sel.Sel.Name != "Wire" {
		return false
	}
	id, ok := sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	obj := pkg.TypesInfo.Uses[id]
	pkgName, ok := obj.(*types.PkgName)
	if !ok {
		return false
	}
	return pkgName.Imported().Path() == wantPath
}

// extractNamedStructType resolves the type of the provided type argument expression,
// ensuring it is a named struct (after pointer/alias deref). Returns the type name and struct.
func extractNamedStructType(pkg *packages.Package, typeExpr ast.Expr) (*types.Named, *types.Struct) {
	tv, ok := pkg.TypesInfo.Types[typeExpr]
	if !ok || tv.Type == nil {
		return nil, nil
	}
	t := deref(tv.Type)
	if n, ok := t.(*types.Named); ok {
		if st, ok := deref(n.Underlying()).(*types.Struct); ok {
			return n, st
		}
	}
	// Anonymous structs are not supported (cannot define methods)
	return nil, nil
}

func deref(t types.Type) types.Type {
	for {
		if p, ok := t.(*types.Pointer); ok {
			t = p.Elem()
			continue
		}
		return t
	}
}

func hasEasyJSON(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, "easyjson:json") {
			return true
		}
	}
	return false
}

func runEasyJSONTypesOnly(pkg *packages.Package, gens map[*types.Named]*types.Struct) error {
	typeSpecByName := map[string]*ast.TypeSpec{}
	fileByName := map[string]*ast.File{}
	fset := pkg.Fset

	for _, f := range pkg.Syntax {
		for _, d := range f.Decls {
			gd, ok := d.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, sp := range gd.Specs {
				ts, ok := sp.(*ast.TypeSpec)
				if !ok || ts.Name == nil {
					continue
				}
				typeSpecByName[ts.Name.Name] = ts
				fileByName[ts.Name.Name] = f
			}
		}
	}

	// ---- Partition targets into local vs external named types ----
	localByDir := map[string][]string{} // dir -> []localTypeName
	for n := range gens {
		npkg := n.Obj().Pkg()
		if npkg != nil && npkg.Path() == pkg.PkgPath {
			// local
			ts := typeSpecByName[n.Obj().Name()]
			if ts == nil {
				continue
			}
			filename := fset.Position(ts.Pos()).Filename
			if filename == "" {
				continue
			}
			dir := filepath.Dir(filename)
			localByDir[dir] = append(localByDir[dir], n.Obj().Name())
		}
	}

	// ---- Handle local types (lift type specs + imports, run easyjson) ----
	for dir, roots := range localByDir {
		pkgName := ""
		if len(roots) > 0 {
			if f := fileByName[roots[0]]; f != nil && f.Name != nil {
				pkgName = f.Name.Name
			}
		}
		if pkgName == "" {
			pkgName = pkg.Name
		}

		// Collect transitive same-package named type dependencies
		seen := map[string]bool{}
		order := make([]*ast.TypeSpec, 0, len(roots)*2)
		var addDeps func(name string)
		addDeps = func(name string) {
			if seen[name] {
				return
			}
			seen[name] = true
			ts := typeSpecByName[name]
			if ts == nil {
				return
			}
			ast.Inspect(ts.Type, func(n ast.Node) bool {
				id, ok := n.(*ast.Ident)
				if !ok || id.Name == "" {
					return true
				}
				if obj, ok := pkg.TypesInfo.Uses[id]; ok {
					if tn, ok := obj.(*types.TypeName); ok {
						if tn.Pkg() != nil && tn.Pkg().Path() == pkg.PkgPath {
							addDeps(tn.Name())
						}
					}
				}
				return true
			})
			order = append(order, ts)
		}
		for _, r := range roots {
			addDeps(r)
		}

		// Build synthetic source: correct package + union of imports + the types
		var src bytes.Buffer
		fmt.Fprintf(&src, "package easyjson_local\n\n")

		importSet := map[string]bool{}
		var importSpecs []*ast.ImportSpec
		seenFiles := map[*ast.File]bool{}
		for _, ts := range order {
			f := fileByName[ts.Name.Name]
			if f == nil || seenFiles[f] {
				continue
			}
			seenFiles[f] = true
			for _, decl := range f.Decls {
				gd, ok := decl.(*ast.GenDecl)
				if !ok || gd.Tok != token.IMPORT {
					continue
				}
				for _, s := range gd.Specs {
					is := s.(*ast.ImportSpec)
					key := ""
					if is.Path != nil {
						key = is.Path.Value
					}
					if !importSet[key] {
						importSet[key] = true
						importSpecs = append(importSpecs, is)
					}
				}
			}
		}
		if len(importSpecs) > 0 {
			src.WriteString("import (\n")
			for _, is := range importSpecs {
				var line bytes.Buffer
				_ = printer.Fprint(&line, fset, is)
				if !strings.HasSuffix(line.String(), "\n") {
					line.WriteByte('\n')
				}
				src.WriteString("\t")
				src.Write(line.Bytes())
			}
			src.WriteString(")\n\n")
		}

		for _, ts := range order {
			if !hasEasyJSON(ts.Doc) {
				src.WriteString("//easyjson:json\n")
			}
			gd := &ast.GenDecl{Tok: token.TYPE, Specs: []ast.Spec{ts}}
			if err := printer.Fprint(&src, fset, gd); err != nil {
				return err
			}
			src.WriteByte('\n')
		}

		tmp := "easyjson_local"
		err := os.Mkdir(tmp, 0755)
		if err != nil {
			return err
		}
		defer os.RemoveAll(tmp)

		formatted, err := imports.Process("types.go", src.Bytes(), &imports.Options{
			Comments:  true,
			TabWidth:  8,
			TabIndent: true,
		})
		if err != nil {
			log.Printf("warning: goimports failed (local): %v", err)
			formatted = src.Bytes()
		}
		if err := os.WriteFile(filepath.Join(tmp, "types.go"), formatted, 0o644); err != nil {
			return err
		}

		cmd := exec.Command("go", "run", "github.com/mailru/easyjson/easyjson@latest", "-all", ".")
		cmd.Dir = tmp
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("easyjson in %s: %w", dir, err)
		}

		ents, err := os.ReadDir(tmp)
		if err != nil {
			return err
		}
		var ezjson []os.DirEntry
		for _, ent := range ents {
			if ent.IsDir() || !strings.HasSuffix(ent.Name(), "_easyjson.go") {
				continue
			}

			ezjson = append(ezjson, ent)
		}

		if len(ezjson) != 1 {
			fmt.Println("expected 1 file in easyjson_local. Found", ezjson)
		}

		e := ezjson[0]
		b, err := os.ReadFile(filepath.Join(tmp, e.Name()))
		if err != nil {
			return err
		}
		b = pkgLineRx.ReplaceAllFunc(b, func(line []byte) []byte {
			if string(bytes.TrimSpace(line)) == "package easyjson_local" {
				return []byte("package main")
			}
			return line
		})
		// Package header already correct; no rewrites to "main".
		dst := filepath.Join(dir, "json_generated.go")
		if err := os.WriteFile(dst, b, 0o644); err != nil {
			return err
		}
	}

	return nil
}
