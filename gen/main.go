package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

const header = `// Code generated by tangentgen; DO NOT EDIT.

`

type fieldSpec struct {
	name      string // field name in output
	goName    string // struct field ident
	omitempty bool
	kind      fieldKind
	elem      types.Type  // for slices/maps element
	isBytes   bool        // []byte special
	fields    []fieldSpec // for nested structs
	isPtr     bool        // original field was a pointer at top-level

	named *types.Named
}

type fieldKind int

const (
	fkUnsupported fieldKind = iota
	fkString
	fkBool
	fkInt
	fkFloat
	fkBytes
	fkSlice
	fkMapString
	fkStruct
)

type genType struct {
	strct  *types.Struct
	fields []fieldSpec
}

func main() {
	log.SetFlags(0)

	var outFile string
	flag.StringVar(&outFile, "o", "", "output filename for generated code (e.g., path/to/file.go); defaults to <Type>_outval_gen.go")
	flag.Parse()

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax |
			packages.NeedCompiledGoFiles | packages.NeedTypes | packages.NeedTypesInfo,
		Dir: ".",
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatalf("load: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	if len(pkgs) == 0 {
		log.Fatalf("no packages found")
	}
	pkg := pkgs[0]

	// Discover the output type by locating a call to tangent_sdk.Wire[T](...)
	toGenerate := findWireOutputTypes(pkg)
	if len(toGenerate) == 0 {
		log.Fatalf("no Wire[T] instantiations found; pass -types or add a tangentgen shim")
	}

	// Add //easyjson:json to those types in-place
	if n := annotateEasyJSON(pkg, toGenerate); n == 0 {
		log.Printf("no types annotated with //easyjson:json (already present or not found)")
	}
}

// findWireOutputType searches the package's syntax for a call to
// github.com/telophasehq/tangent-sdk-go.Wire[T](...) and returns the
// name of T and its underlying struct type. Only named struct types are supported.
func findWireOutputTypes(pkg *packages.Package) map[string]*types.Struct {
	const tangentImportPath = "github.com/telophasehq/tangent-sdk-go"
	out := map[string]*types.Struct{}
	for _, f := range pkg.Syntax {
		ast.Inspect(f, func(n ast.Node) bool {
			call, ok := n.(*ast.CallExpr)
			if !ok {
				return true
			}
			switch fun := call.Fun.(type) {
			case *ast.IndexExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if name, st := extractNamedStructType(pkg, fun.Index); st != nil {
					out[name] = st
				}
			case *ast.IndexListExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if len(fun.Indices) > 0 {
					if name, st := extractNamedStructType(pkg, fun.Indices[0]); st != nil {
						out[name] = st
					}
				}
			}
			return true
		})
	}
	return out
}

// isTangentWire reports whether expr is a selector to the Wire symbol in the tangent SDK import.
func isTangentWire(pkg *packages.Package, expr ast.Expr, wantPath string) bool {
	sel, ok := expr.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	if sel.Sel == nil || sel.Sel.Name != "Wire" {
		return false
	}
	id, ok := sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	obj := pkg.TypesInfo.Uses[id]
	pkgName, ok := obj.(*types.PkgName)
	if !ok {
		return false
	}
	return pkgName.Imported().Path() == wantPath
}

// extractNamedStructType resolves the type of the provided type argument expression,
// ensuring it is a named struct (after pointer/alias deref). Returns the type name and struct.
func extractNamedStructType(pkg *packages.Package, typeExpr ast.Expr) (string, *types.Struct) {
	tv, ok := pkg.TypesInfo.Types[typeExpr]
	if !ok || tv.Type == nil {
		return "", nil
	}
	t := deref(tv.Type)
	if n, ok := t.(*types.Named); ok {
		if st, ok := deref(n.Underlying()).(*types.Struct); ok {
			return n.Obj().Name(), st
		}
	}
	// Anonymous structs are not supported (cannot define methods)
	return "", nil
}

func deref(t types.Type) types.Type {
	for {
		if p, ok := t.(*types.Pointer); ok {
			t = p.Elem()
			continue
		}
		return t
	}
}

func annotateEasyJSON(pkg *packages.Package, gens map[string]*types.Struct) int {
	nameSet := map[string]struct{}{}
	for name := range gens {
		nameSet[name] = struct{}{}
	}

	var changedCount int
	for _, f := range pkg.Syntax {
		fileChanged := false

		for _, d := range f.Decls {
			gd, ok := d.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, sp := range gd.Specs {
				ts, ok := sp.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if _, ok := nameSet[ts.Name.Name]; !ok {
					continue
				}
				if _, ok := ts.Type.(*ast.StructType); !ok {
					continue
				}
				if hasEasyJSON(ts.Doc) || hasEasyJSON(gd.Doc) {
					continue
				}

				c := &ast.Comment{Text: "//easyjson:json"}
				if ts.Doc == nil {
					ts.Doc = &ast.CommentGroup{List: []*ast.Comment{c}}
				} else {
					ts.Doc.List = append([]*ast.Comment{c}, ts.Doc.List...)
				}
				fileChanged = true
				changedCount++
			}
		}

		if fileChanged {
			var buf bytes.Buffer
			if err := format.Node(&buf, pkg.Fset, f); err == nil {
				filename := pkg.Fset.File(f.Pos()).Name()
				_ = os.WriteFile(filename, buf.Bytes(), 0644)
			}
		}
	}
	return changedCount
}

func hasEasyJSON(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, "easyjson:json") {
			return true
		}
	}
	return false
}
