package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

const header = `// Code generated by tangentgen; DO NOT EDIT.

`

type fieldSpec struct {
	name      string // field name in output
	goName    string // struct field ident
	omitempty bool
	kind      fieldKind
	elem      types.Type  // for slices/maps element
	isBytes   bool        // []byte special
	fields    []fieldSpec // for nested structs
	isPtr     bool        // original field was a pointer at top-level

	named *types.Named
}

type fieldKind int

const (
	fkUnsupported fieldKind = iota
	fkString
	fkBool
	fkInt
	fkFloat
	fkBytes
	fkSlice
	fkMapString
	fkStruct
)

type genType struct {
	strct  *types.Struct
	fields []fieldSpec
}

func main() {
	log.SetFlags(0)

	var outFile string
	flag.StringVar(&outFile, "o", "", "output filename for generated code (e.g., path/to/file.go); defaults to <Type>_outval_gen.go")
	flag.Parse()

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax |
			packages.NeedCompiledGoFiles | packages.NeedTypes | packages.NeedTypesInfo,
		Dir: ".",
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatalf("load: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	if len(pkgs) == 0 {
		log.Fatalf("no packages found")
	}
	pkg := pkgs[0]

	// Discover the output type by locating a call to tangent_sdk.Wire[T](...)
	toGenerate := findWireOutputTypes(pkg)
	if len(toGenerate) == 0 {
		log.Fatalf("no Wire[T] instantiations found; pass -types or add a tangentgen shim")
	}

	// Build output
	var out bytes.Buffer
	out.WriteString(header)
	fmt.Fprintf(&out, "package %s\n\n", pkg.Name)
	out.WriteString("import (\n")
	fmt.Fprintf(&out, "\tpluginout %q\n", "github.com/telophasehq/tangent-sdk-go")
	out.WriteString(")\n\n")

	for name, st := range toGenerate {
		fields := analyzeStruct(st)

		generateAll(&out, name, fields)
	}

	// gofmt
	formatted, err := format.Source(out.Bytes())
	var outPath string
	if outFile != "" {
		outPath = outFile
	} else {
		outPath = "outval_gen.go"
	}
	if err != nil {
		// write raw for debugging
		rawPath := outPath + ".raw"
		_ = os.WriteFile(rawPath, out.Bytes(), 0644)
		log.Fatalf("format: %v (wrote %s)", err, rawPath)
	}

	// write file near the package
	if err := os.WriteFile(outPath, formatted, 0644); err != nil {
		log.Fatalf("write: %v", err)
	}
}

// findWireOutputType searches the package's syntax for a call to
// github.com/telophasehq/tangent-sdk-go.Wire[T](...) and returns the
// name of T and its underlying struct type. Only named struct types are supported.
func findWireOutputTypes(pkg *packages.Package) map[string]*types.Struct {
	const tangentImportPath = "github.com/telophasehq/tangent-sdk-go"
	out := map[string]*types.Struct{}
	for _, f := range pkg.Syntax {
		ast.Inspect(f, func(n ast.Node) bool {
			call, ok := n.(*ast.CallExpr)
			if !ok {
				return true
			}
			switch fun := call.Fun.(type) {
			case *ast.IndexExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if name, st := extractNamedStructType(pkg, fun.Index); st != nil {
					out[name] = st
				}
			case *ast.IndexListExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if len(fun.Indices) > 0 {
					if name, st := extractNamedStructType(pkg, fun.Indices[0]); st != nil {
						out[name] = st
					}
				}
			}
			return true
		})
	}
	return out
}

// isTangentWire reports whether expr is a selector to the Wire symbol in the tangent SDK import.
func isTangentWire(pkg *packages.Package, expr ast.Expr, wantPath string) bool {
	sel, ok := expr.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	if sel.Sel == nil || sel.Sel.Name != "Wire" {
		return false
	}
	id, ok := sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	obj := pkg.TypesInfo.Uses[id]
	pkgName, ok := obj.(*types.PkgName)
	if !ok {
		return false
	}
	return pkgName.Imported().Path() == wantPath
}

// extractNamedStructType resolves the type of the provided type argument expression,
// ensuring it is a named struct (after pointer/alias deref). Returns the type name and struct.
func extractNamedStructType(pkg *packages.Package, typeExpr ast.Expr) (string, *types.Struct) {
	tv, ok := pkg.TypesInfo.Types[typeExpr]
	if !ok || tv.Type == nil {
		return "", nil
	}
	t := deref(tv.Type)
	if n, ok := t.(*types.Named); ok {
		if st, ok := deref(n.Underlying()).(*types.Struct); ok {
			return n.Obj().Name(), st
		}
	}
	// Anonymous structs are not supported (cannot define methods)
	return "", nil
}

func generateAll(buf *bytes.Buffer, rootName string, rootFields []fieldSpec) {
	structsToGen := map[string][]fieldSpec{
		rootName: rootFields,
	}
	seen := map[string]bool{}

	for typeName, fields := range structsToGen {
		if seen[typeName] {
			continue
		}
		seen[typeName] = true

		fmt.Fprintf(buf, "// AppendToArena appends %s into the arena as an object and returns the root node index.\n", typeName)
		fmt.Fprintf(buf, "func (x %s) AppendToArena(ab *pluginout.ArenaBuilder, st *pluginout.StringTable) uint32 {\n", typeName)
		fmt.Fprintf(buf, "\tab.ObjectStartReserve(%d)\n\n", len(fields))
		emitFields(buf, "x", fields, structsToGen)
		fmt.Fprintf(buf, "\n\treturn ab.ObjectEnd()\n")
		fmt.Fprintf(buf, "}\n\n")
	}
}

func emitFields(buf *bytes.Buffer, recv string, fields []fieldSpec, structsToGen map[string][]fieldSpec) {
	for _, f := range fields {
		switch f.kind {
		case fkString:
			if f.isPtr {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != nil && *%s.%s != \"\" {\n", recv, f.goName, recv, f.goName)
				} else {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_str_idx := ab.String(*%s.%s)\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_str_idx)\n", f.name, f.goName)
				fmt.Fprintf(buf, "\t}\n")
			} else {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != \"\" {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_str_idx := ab.String(%s.%s)\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_str_idx)\n", f.name, f.goName)
				if f.omitempty {
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		case fkBool:
			if f.isPtr {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != nil && *%s.%s {\n", recv, f.goName, recv, f.goName)
				} else {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_bool_idx := ab.Bool(*%s.%s)\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_bool_idx)\n", f.name, f.goName)
				fmt.Fprintf(buf, "\t}\n")
			} else {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_bool_idx := ab.Bool(%s.%s)\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_bool_idx)\n", f.name, f.goName)
				if f.omitempty {
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		case fkInt:
			if f.isPtr {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != nil && *%s.%s != 0 {\n", recv, f.goName, recv, f.goName)
				} else {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_int_idx := ab.Int(int64(*%s.%s))\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_int_idx)\n", f.name, f.goName)
				fmt.Fprintf(buf, "\t}\n")
			} else {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != 0 {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_int_idx := ab.Int(int64(%s.%s))\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_int_idx)\n", f.name, f.goName)
				if f.omitempty {
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		case fkFloat:
			if f.isPtr {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != nil && *%s.%s != 0 {\n", recv, f.goName, recv, f.goName)
				} else {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_float_idx := ab.Float(float64(*%s.%s))\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_float_idx)\n", f.name, f.goName)
				fmt.Fprintf(buf, "\t}\n")
			} else {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != 0 {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t%s_float_idx := ab.Float(float64(%s.%s))\n", f.goName, recv, f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_float_idx)\n", f.name, f.goName)
				if f.omitempty {
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		case fkBytes:
			if f.omitempty {
				fmt.Fprintf(buf, "\tif len(%s.%s) != 0 {\n", recv, f.goName)
			}
			fmt.Fprintf(buf, "\t\t%s_bytes_idx := ab.Bytes(%s.%s)\n", f.goName, recv, f.goName)
			fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_bytes_idx)\n", f.name, f.goName)
			if f.omitempty {
				fmt.Fprintf(buf, "\t}\n")
			}
		case fkSlice:
			if f.isPtr {
				// pointer to slice/array
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != nil && len(*%s.%s) != 0 {\n", recv, f.goName, recv, f.goName)
				} else {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\tab.ArrayStartReserve(len(*%s.%s))\n", recv, f.goName)
				fmt.Fprintf(buf, "\t\tfor i := range (*%s.%s) {\n", recv, f.goName)
				if _, ok := f.elem.(*types.Named); ok {
					fmt.Fprintf(buf, "\t\t\tab.ArrayAdd((*%s.%s)[i].AppendToArena(ab, st))\n", recv, f.goName)
				} else if kind := classify(f.elem); kind != fkUnsupported {
					emitElemAppend(buf, "(*"+recv+"."+f.goName+")[i]", kind)
				} else {
					fmt.Fprintf(buf, "\t\t\tab.ArrayAdd((*%s.%s)[i].AppendToArena(ab, st))\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t}\n")
				fmt.Fprintf(buf, "\t\t%s_slice_idx := ab.ArrayEnd()\n", f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_slice_idx)\n", f.name, f.goName)
				fmt.Fprintf(buf, "\t}\n")
			} else {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif len(%s.%s) != 0 {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\tab.ArrayStartReserve(len(%s.%s))\n", recv, f.goName)
				fmt.Fprintf(buf, "\t\tfor i := range %s.%s {\n", recv, f.goName)
				if _, ok := f.elem.(*types.Named); ok {
					fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(%s.%s[i].AppendToArena(ab, st))\n", recv, f.goName)
				} else if kind := classify(f.elem); kind != fkUnsupported {
					emitElemAppend(buf, recv+"."+f.goName+"[i]", kind)
				} else {
					fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(%s.%s[i].AppendToArena(ab, st))\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\t}\n")
				fmt.Fprintf(buf, "\t\t%s_slice_idx := ab.ArrayEnd()\n", f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_slice_idx)\n", f.name, f.goName)
				if f.omitempty {
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		case fkMapString:
			if f.isPtr {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif %s.%s != nil && len(*%s.%s) != 0 {\n", recv, f.goName, recv, f.goName)
				} else {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\tab.ObjectStartReserve(len(*%s.%s))\n", recv, f.goName)
				fmt.Fprintf(buf, "\t\tfor k, v := range *%s.%s {\n", recv, f.goName)
				if _, ok := f.elem.(*types.Named); ok {
					fmt.Fprintf(buf, "\t\t\tab.ObjectAdd(ab.Field(k, v.AppendToArena(ab, st)))\n")
				} else if kind := classify(f.elem); kind != fkUnsupported {
					emitElemAppendKV(buf, "v", kind)
				} else {
					fmt.Fprintf(buf, "\t\t\tab.ObjectAdd(ab.Field(k, v.AppendToArena(ab, st)))\n")
				}
				fmt.Fprintf(buf, "\t\t}\n")
				fmt.Fprintf(buf, "\t\t%s_map_idx := ab.ObjectEnd()\n", f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_map_idx)\n", f.name, f.goName)
				fmt.Fprintf(buf, "\t}\n")
			} else {
				if f.omitempty {
					fmt.Fprintf(buf, "\tif len(%s.%s) != 0 {\n", recv, f.goName)
				}
				fmt.Fprintf(buf, "\t\tab.ObjectStartReserve(len(%s.%s))\n", recv, f.goName)
				fmt.Fprintf(buf, "\t\tfor k, v := range %s.%s {\n", recv, f.goName)
				if _, ok := f.elem.(*types.Named); ok {
					fmt.Fprintf(buf, "\t\t\tab.ObjectAdd(ab.Field(k, v.AppendToArena(ab, st)))\n")
				} else if kind := classify(f.elem); kind != fkUnsupported {
					emitElemAppendKV(buf, "v", kind)
				} else {
					fmt.Fprintf(buf, "\t\t\tab.ObjectAdd(ab.Field(k, v.AppendToArena(ab, st)))\n")
				}
				fmt.Fprintf(buf, "\t\t}\n")
				fmt.Fprintf(buf, "\t\t%s_map_idx := ab.ObjectEnd()\n", f.goName)
				fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_map_idx)\n", f.name, f.goName)
				if f.omitempty {
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		case fkStruct:
			if f.named != nil {
				if f.isPtr {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
					fmt.Fprintf(buf, "\t\t%s_struct_idx := %s.%s.AppendToArena(ab, st)\n", f.goName, recv, f.goName)
					fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_struct_idx)\n", f.name, f.goName)
					fmt.Fprintf(buf, "\t}\n")
				} else {
					fmt.Fprintf(buf, "\t{\n")
					fmt.Fprintf(buf, "\t\t%s_struct_idx := %s.%s.AppendToArena(ab, st)\n", f.goName, recv, f.goName)
					fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_struct_idx)\n", f.name, f.goName)
					fmt.Fprintf(buf, "\t}\n")
				}
				tn := f.named.Obj().Name()
				if _, ok := structsToGen[tn]; !ok {
					structsToGen[tn] = f.fields
				}
			} else {
				if f.isPtr {
					fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, f.goName)
					fmt.Fprintf(buf, "\t\tab.ObjectStartReserve(%d)\n", len(f.fields))
					emitFields(buf, "(*"+recv+"."+f.goName+")", f.fields, structsToGen)
					fmt.Fprintf(buf, "\t\t%s_struct_idx := ab.ObjectEnd()\n", f.goName)
					fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_struct_idx)\n", f.name, f.goName)

					fmt.Fprintf(buf, "\t}\n")
				} else {
					fmt.Fprintf(buf, "\t{\n")
					fmt.Fprintf(buf, "\t\tab.ObjectStartReserve(%d)\n", len(f.fields))
					emitFields(buf, recv+"."+f.goName, f.fields, structsToGen)
					fmt.Fprintf(buf, "\t\t%s_struct_idx := ab.ObjectEnd()\n", f.goName)
					fmt.Fprintf(buf, "\t\tab.ObjectAddFieldKey(%q, %s_struct_idx)\n", f.name, f.goName)
					fmt.Fprintf(buf, "\t}\n")
				}
			}
		default:
			// skip unsupported
		}
	}
}

func emitElemAppend(buf *bytes.Buffer, expr string, kind fieldKind) {
	switch kind {
	case fkString:
		fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(ab.String(%s))\n", expr)
	case fkBool:
		fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(ab.Bool(%s))\n", expr)
	case fkInt:
		fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(ab.Int(int64(%s)))\n", expr)
	case fkFloat:
		fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(ab.Float(float64(%s)))\n", expr)
	case fkBytes:
		fmt.Fprintf(buf, "\t\t\tab.ArrayAdd(ab.Bytes(%s))\n", expr)
	default:
		// no-op
	}
}

func emitElemAppendKV(buf *bytes.Buffer, expr string, kind fieldKind) {
	switch kind {
	case fkString:
		fmt.Fprintf(buf, "\t\t\tab.ObjectAddFieldKey(k, ab.String(%s))\n", expr)
	case fkBool:
		fmt.Fprintf(buf, "\t\t\tab.ObjectAddFieldKey(k, ab.Bool(%s))\n", expr)
	case fkInt:
		fmt.Fprintf(buf, "\t\t\tab.ObjectAddFieldKey(k, ab.Int(int64(%s)))\n", expr)
	case fkFloat:
		fmt.Fprintf(buf, "\t\t\tab.ObjectAddFieldKey(k, ab.Float(float64(%s)))\n", expr)
	case fkBytes:
		fmt.Fprintf(buf, "\t\t\tab.ObjectAddFieldKey(k, ab.Bytes(%s))\n", expr)
	}
}

func analyzeStruct(st *types.Struct) []fieldSpec {
	var out []fieldSpec
	for i := 0; i < st.NumFields(); i++ {
		f := st.Field(i)
		if !f.Exported() {
			continue
		}
		tag := st.Tag(i)
		name, omitempty, skip := parseOutTag(tag, f.Name())
		if skip {
			continue
		}
		typ := f.Type()
		spec := fieldSpec{
			name:      name,
			goName:    f.Name(),
			omitempty: omitempty,
			isPtr:     hasTopLevelPointer(typ),
		}
		switch t := deref(typ).(type) {
		case *types.Basic:
			switch {
			case t.Info()&types.IsString != 0:
				spec.kind = fkString
			case t.Info()&types.IsBoolean != 0:
				spec.kind = fkBool
			case t.Info()&types.IsInteger != 0:
				spec.kind = fkInt
			case t.Info()&types.IsFloat != 0:
				spec.kind = fkFloat
			default:
				spec.kind = fkUnsupported
			}
		case *types.Slice:
			if bas, ok := deref(t.Elem()).(*types.Basic); ok && bas.Info()&types.IsInteger != 0 && bas.Kind() == types.Byte {
				spec.kind = fkBytes
				spec.isBytes = true
			} else {
				spec.kind = fkSlice
				spec.elem = t.Elem()
			}
		case *types.Array:
			// treat arrays like slices
			if bas, ok := deref(t.Elem()).(*types.Basic); ok && bas.Info()&types.IsInteger != 0 && bas.Kind() == types.Byte {
				spec.kind = fkBytes
				spec.isBytes = true
			} else {
				spec.kind = fkSlice
				spec.elem = t.Elem()
			}
		case *types.Map:
			if kb, ok := deref(t.Key()).(*types.Basic); ok && kb.Info()&types.IsString != 0 {
				spec.kind = fkMapString
				spec.elem = t.Elem()
			} else {
				spec.kind = fkUnsupported
			}
		case *types.Named:
			if ust, ok := deref(t.Underlying()).(*types.Struct); ok {
				spec.kind = fkStruct
				spec.named = t
				spec.fields = analyzeStruct(ust)
			} else {
				spec.kind = fkUnsupported
			}
		case *types.Struct:
			spec.kind = fkStruct
			spec.fields = analyzeStruct(t)
		default:
			spec.kind = fkUnsupported
		}
		out = append(out, spec)
	}
	return out
}

func parseOutTag(tag string, defaultName string) (name string, omitempty bool, skip bool) {
	const key = "`json:\""
	i := strings.Index(tag, `json:"`)
	if i < 0 {
		return defaultName, false, false
	}
	j := i + len(`json:"`)
	k := strings.Index(tag[j:], `"`)
	if k < 0 {
		return defaultName, false, false
	}
	val := tag[j : j+k]
	if val == "-" {
		return "", false, true
	}
	parts := strings.Split(val, ",")
	name = parts[0]
	if name == "" {
		name = defaultName
	}
	for _, p := range parts[1:] {
		if strings.TrimSpace(p) == "omitempty" {
			omitempty = true
		}
	}
	return name, omitempty, false
}

func deref(t types.Type) types.Type {
	for {
		if p, ok := t.(*types.Pointer); ok {
			t = p.Elem()
			continue
		}
		return t
	}
}

func hasTopLevelPointer(t types.Type) bool {
	for {
		switch tt := t.(type) {
		case *types.Pointer:
			return true
		case *types.Named:
			t = tt.Underlying()
			continue
		default:
			return false
		}
	}
}

func classify(t types.Type) fieldKind {
	t = deref(t)
	switch b := t.(type) {
	case *types.Basic:
		switch {
		case b.Info()&types.IsString != 0:
			return fkString
		case b.Info()&types.IsBoolean != 0:
			return fkBool
		case b.Info()&types.IsInteger != 0:
			return fkInt
		case b.Info()&types.IsFloat != 0:
			return fkFloat
		default:
			return fkUnsupported
		}
	case *types.Slice:
		if bas, ok := deref(b.Elem()).(*types.Basic); ok && bas.Kind() == types.Byte {
			return fkBytes
		}
		return fkSlice
	case *types.Array:
		if bas, ok := deref(b.Elem()).(*types.Basic); ok && bas.Kind() == types.Byte {
			return fkBytes
		}
		return fkSlice
	case *types.Map:
		if kb, ok := deref(b.Key()).(*types.Basic); ok && kb.Info()&types.IsString != 0 {
			return fkMapString
		}
		return fkUnsupported
	case *types.Struct, *types.Named:
		return fkStruct
	default:
		return fkUnsupported
	}
}
