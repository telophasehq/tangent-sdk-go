package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"go/types"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const header = `// Code generated by tangentgen; DO NOT EDIT.

`

var pkgLineRx = regexp.MustCompile(`(?m)^package\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*$`)

type fieldSpec struct {
	name      string // field name in output
	goName    string // struct field ident
	omitempty bool
	kind      fieldKind
	elem      types.Type  // for slices/maps element
	isBytes   bool        // []byte special
	fields    []fieldSpec // for nested structs
	isPtr     bool        // original field was a pointer at top-level

	named *types.Named
}

type fieldKind int

const (
	fkUnsupported fieldKind = iota
	fkString
	fkBool
	fkInt
	fkFloat
	fkBytes
	fkSlice
	fkMapString
	fkStruct
)

type genType struct {
	strct  *types.Struct
	fields []fieldSpec
}

func main() {
	log.SetFlags(0)

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax |
			packages.NeedCompiledGoFiles | packages.NeedTypes | packages.NeedTypesInfo,
		Dir: ".",
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatalf("load: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}
	if len(pkgs) == 0 {
		log.Fatalf("no packages found")
	}
	pkg := pkgs[0]

	// Discover the output type by locating a call to tangent_sdk.Wire[T](...)
	toGenerate := findWireOutputTypes(pkg)
	if len(toGenerate) == 0 {
		log.Fatalf("no Wire[T] instantiations found; pass -types or add a tangentgen shim")
	}

	// Add //easyjson:json to those types in-place
	changedFiles := annotateEasyJSON(pkg, toGenerate)
	if len(changedFiles) == 0 {
		log.Printf("no types annotated with //easyjson:json (already present or not found)")
	} else {
		if err := runEasyJSONTypesOnly(pkg, toGenerate); err != nil {
			log.Fatalf("easyjson generate failed: %v", err)
		}
	}
}

// findWireOutputType searches the package's syntax for a call to
// github.com/telophasehq/tangent-sdk-go.Wire[T](...) and returns the
// name of T and its underlying struct type. Only named struct types are supported.
func findWireOutputTypes(pkg *packages.Package) map[string]*types.Struct {
	const tangentImportPath = "github.com/telophasehq/tangent-sdk-go"
	out := map[string]*types.Struct{}
	for _, f := range pkg.Syntax {
		ast.Inspect(f, func(n ast.Node) bool {
			call, ok := n.(*ast.CallExpr)
			if !ok {
				return true
			}
			switch fun := call.Fun.(type) {
			case *ast.IndexExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if name, st := extractNamedStructType(pkg, fun.Index); st != nil {
					out[name] = st
				}
			case *ast.IndexListExpr:
				if !isTangentWire(pkg, fun.X, tangentImportPath) {
					return true
				}
				if len(fun.Indices) > 0 {
					if name, st := extractNamedStructType(pkg, fun.Indices[0]); st != nil {
						out[name] = st
					}
				}
			}
			return true
		})
	}
	return out
}

// isTangentWire reports whether expr is a selector to the Wire symbol in the tangent SDK import.
func isTangentWire(pkg *packages.Package, expr ast.Expr, wantPath string) bool {
	sel, ok := expr.(*ast.SelectorExpr)
	if !ok {
		return false
	}
	if sel.Sel == nil || sel.Sel.Name != "Wire" {
		return false
	}
	id, ok := sel.X.(*ast.Ident)
	if !ok {
		return false
	}
	obj := pkg.TypesInfo.Uses[id]
	pkgName, ok := obj.(*types.PkgName)
	if !ok {
		return false
	}
	return pkgName.Imported().Path() == wantPath
}

// extractNamedStructType resolves the type of the provided type argument expression,
// ensuring it is a named struct (after pointer/alias deref). Returns the type name and struct.
func extractNamedStructType(pkg *packages.Package, typeExpr ast.Expr) (string, *types.Struct) {
	tv, ok := pkg.TypesInfo.Types[typeExpr]
	if !ok || tv.Type == nil {
		return "", nil
	}
	t := deref(tv.Type)
	if n, ok := t.(*types.Named); ok {
		if st, ok := deref(n.Underlying()).(*types.Struct); ok {
			return n.Obj().Name(), st
		}
	}
	// Anonymous structs are not supported (cannot define methods)
	return "", nil
}

func deref(t types.Type) types.Type {
	for {
		if p, ok := t.(*types.Pointer); ok {
			t = p.Elem()
			continue
		}
		return t
	}
}

func annotateEasyJSON(pkg *packages.Package, gens map[string]*types.Struct) []string {
	// Build lookup set
	nameSet := make(map[string]struct{}, len(gens))
	for name := range gens {
		nameSet[name] = struct{}{}
	}

	var changedFiles []string
	fset := pkg.Fset

	for _, file := range pkg.Syntax {
		found := false

		ast.Inspect(file, func(n ast.Node) bool {
			genDecl, ok := n.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				return true
			}
			for _, spec := range genDecl.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				// target only named structs we care about
				if _, ok := nameSet[ts.Name.Name]; !ok {
					continue
				}
				if _, ok := ts.Type.(*ast.StructType); !ok {
					continue
				}
				found = true

				if hasEasyJSON(ts.Doc) || hasEasyJSON(genDecl.Doc) {
					continue
				}

				// Attach the directive in a place the printer will actually emit:
				// - if the declaration is grouped (type (...)), attach to the TypeSpec doc
				// - otherwise attach to the GenDecl doc (spec.Doc is ignored for single-spec decls)
				var targetDoc **ast.CommentGroup
				var slash token.Pos
				if genDecl.Lparen.IsValid() {
					targetDoc = &ts.Doc
					slash = ts.Pos() - 1
				} else {
					targetDoc = &genDecl.Doc
					slash = genDecl.Pos() - 1
				}
				c := &ast.Comment{Slash: slash, Text: "//easyjson:json"}
				if *targetDoc == nil {
					*targetDoc = &ast.CommentGroup{List: []*ast.Comment{c}}
				} else {
					// ensure our inserted comment is earliest
					if len((*targetDoc).List) > 0 && (*targetDoc).List[0].Slash <= c.Slash {
						c.Slash = (*targetDoc).List[0].Slash - 1
					}
					(*targetDoc).List = append([]*ast.Comment{c}, (*targetDoc).List...)
				}
			}
			return true
		})

		if found {
			var buf bytes.Buffer
			if err := printer.Fprint(&buf, fset, file); err != nil {
				panic(err)
			}

			// Use the filename associated with this *ast.File via the FileSet
			filename := fset.File(file.Package).Name()
			if filename == "" {
				// Fallback: derive from file.Pos()
				filename = fset.Position(file.Pos()).Filename
			}

			if err := os.WriteFile(filename, buf.Bytes(), 0o644); err != nil {
				panic(err)
			}
			changedFiles = append(changedFiles, filename)
		}
	}

	return changedFiles
}

func hasEasyJSON(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, "easyjson:json") {
			return true
		}
	}
	return false
}

func runEasyJSONTypesOnly(pkg *packages.Package, gens map[string]*types.Struct) error {
	// Index: name -> *ast.TypeSpec, and file -> imports
	typeSpecByName := map[string]*ast.TypeSpec{}
	fileByName := map[string]*ast.File{}

	fset := pkg.Fset
	for _, f := range pkg.Syntax {
		// Record all type specs in this file
		for _, d := range f.Decls {
			gd, ok := d.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, sp := range gd.Specs {
				ts, ok := sp.(*ast.TypeSpec)
				if !ok || ts.Name == nil {
					continue
				}
				typeSpecByName[ts.Name.Name] = ts
				fileByName[ts.Name.Name] = f
			}
		}
	}

	// Group target type names by directory of their declaring file
	namesByDir := map[string][]string{}
	for name := range gens {
		ts := typeSpecByName[name]
		if ts == nil {
			continue
		}
		filename := fset.Position(ts.Pos()).Filename
		if filename == "" {
			continue
		}
		dir := filepath.Dir(filename)
		namesByDir[dir] = append(namesByDir[dir], name)
	}

	// For each dir, build a synthetic file with needed types and imports, run easyjson, bring back
	for dir, roots := range namesByDir {
		base := filepath.Base(dir)

		// Collect transitive same-package named type dependencies (DFS over AST idents)
		seen := map[string]bool{}
		order := make([]*ast.TypeSpec, 0, len(roots)*2) // rough
		var addDeps func(name string)
		addDeps = func(name string) {
			if seen[name] {
				return
			}
			seen[name] = true
			ts := typeSpecByName[name]
			if ts == nil {
				return
			}
			// Recurse over referenced same-package type names
			ast.Inspect(ts.Type, func(n ast.Node) bool {
				id, ok := n.(*ast.Ident)
				if !ok || id.Name == "" {
					return true
				}
				// Resolve type names only
				if obj, ok := pkg.TypesInfo.Uses[id]; ok {
					if tn, ok := obj.(*types.TypeName); ok {
						// Only same-package named types
						if tn.Pkg() != nil && tn.Pkg().Path() == pkg.PkgPath {
							addDeps(tn.Name())
						}
					}
				}
				return true
			})
			order = append(order, ts)
		}
		for _, r := range roots {
			addDeps(r)
		}

		// Build synthetic source: package + imports (union of import specs from declaring files) + types
		var src bytes.Buffer
		fmt.Fprintf(&src, "package %s\n\n", base)

		// Gather imports from files that declare any included types; de-dup by import path literal
		importSet := map[string]bool{}
		var importSpecs []*ast.ImportSpec
		seenFiles := map[*ast.File]bool{}
		for _, ts := range order {
			f := fileByName[ts.Name.Name]
			if f == nil || seenFiles[f] {
				continue
			}
			seenFiles[f] = true
			for _, decl := range f.Decls {
				gd, ok := decl.(*ast.GenDecl)
				if !ok || gd.Tok != token.IMPORT {
					continue
				}
				for _, s := range gd.Specs {
					is := s.(*ast.ImportSpec)
					// path literal as key (includes quotes)
					key := ""
					if is.Path != nil {
						key = is.Path.Value
					}
					if !importSet[key] {
						importSet[key] = true
						importSpecs = append(importSpecs, is)
					}
				}
			}
		}
		if len(importSpecs) > 0 {
			src.WriteString("import (\n")
			for _, is := range importSpecs {
				var line bytes.Buffer
				_ = printer.Fprint(&line, fset, is)
				// Ensure trailing newline
				if !strings.HasSuffix(line.String(), "\n") {
					line.WriteByte('\n')
				}
				src.WriteString("\t")
				src.Write(line.Bytes())
			}
			src.WriteString(")\n\n")
		}

		// Emit //easyjson:json and type specs in collected order
		for _, ts := range order {
			if !hasEasyJSON(ts.Doc) {
				src.WriteString("//easyjson:json\n")
			}
			gd := &ast.GenDecl{
				Tok:   token.TYPE,
				Specs: []ast.Spec{ts},
			}
			if err := printer.Fprint(&src, fset, gd); err != nil {
				return err
			}
			src.WriteByte('\n')
		}

		// Temp workspace
		tmp := "easyjson_types"
		err := os.Mkdir(tmp, 0755)
		if err != nil {
			return err
		}
		defer os.RemoveAll(tmp)

		formatted, err := imports.Process("types.go", src.Bytes(), &imports.Options{
			Comments:  true,
			TabWidth:  8,
			TabIndent: true,
		})
		if err != nil {
			log.Printf("warning: goimports failed: %v", err)
			formatted = src.Bytes() // fall back
		}
		if err := os.WriteFile(filepath.Join(tmp, "types.go"), formatted, 0o644); err != nil {
			return err
		}

		// Run easyjson
		cmd := exec.Command("go", "run", "github.com/mailru/easyjson/easyjson@latest", "-all", ".")
		cmd.Dir = tmp
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("easyjson in %s: %w", dir, err)
		}

		ents, err := os.ReadDir(tmp)
		if err != nil {
			return err
		}
		for _, e := range ents {
			if e.IsDir() || !strings.HasSuffix(e.Name(), "_easyjson.go") {
				continue
			}
			b, err := os.ReadFile(filepath.Join(tmp, e.Name()))
			if err != nil {
				return err
			}
			b = pkgLineRx.ReplaceAllFunc(b, func(line []byte) []byte {
				if string(bytes.TrimSpace(line)) == "package "+base {
					return []byte("package main")
				}
				return line
			})
			dst := filepath.Join(dir, "json_generated.go")
			if err := os.WriteFile(dst, b, 0o644); err != nil {
				return err
			}
		}
	}

	return nil
}
